---
title: Redis分布式锁的问题总结
author: 鹏徙南冥
top: false
mathjax: false
categories:
  - redis
tags:
  - java
  - redis
date: 2019-06-17 11:50:04
updated: 2019-06-17 11:50:04
img:
summary:
---

Redis分布式锁的实现过程，相信在搜索引擎上已经可以获得足够多的答案。但是之前在查看这方面的内容时，确发现存在着各式各样可能存在的问题，并很少有文章能涉及全面。本文旨在对这些问题进行统一的记录整理，以方便在遇到问题时排查或在设计时作为参考。

值得一提的是，本文中所有的问题，也不一定是最终的所有问题，并且考虑到使用者采用的方式、语言等的差异，本文所指的问题，皆为采用Java Jedis的前提下实现需要考虑的问题。如果使用的是Redission或者RedLock等其他方式，还需要使用者酌情进行判断。

## 为锁设置默认的超时时间
锁的超时问题是比较容易考虑到也比较容易规避的一个问题。其存在的意义在于防止客户端获取到锁之后出现异常导致锁无法被释放。

就一般而言，分布式锁应该试下如下逻辑：
![](https://s2.ax1x.com/2019/06/17/VHNanA.png)

上图中的锁是没有设置默认过期时间的实现。如果client 1在获取到锁之后出现异常，导致锁无法被正常释放，那么其他客户端将无法再获得这个锁，如下图所示：
![](https://s2.ax1x.com/2019/06/17/VHNNXd.png)

当加上默认超时时间之后，即便是client 1出现了异常没有释放锁，其他客户端也可以在锁超时之后重新获取到锁。
![](https://s2.ax1x.com/2019/06/17/VHNd0I.png)
## 锁过期
锁过期的一个表现是，客户端由于一些原因导致执行过程比预想的要长，甚至长过了锁的过期时间。这样client 1的业务还没处理完，锁已经被释放了。这样实际上锁就没有起到控制并发的作用了。

一个简单的方案是，增加锁自动过期的时间。尽管
## 锁未同步

## 锁获取超时

## 锁重入

## 参考
